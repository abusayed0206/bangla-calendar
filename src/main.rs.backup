#![windows_subsystem = "windows"]

use std::sync::atomic::{AtomicBool, AtomicU32, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
use windows::{
    core::*,
    Win32::Foundation::*,
    Win32::Graphics::Gdi::*,
    Win32::Graphics::Dwm::*,
    Win32::System::LibraryLoader::GetModuleHandleW,
    Win32::System::Registry::*,
    Win32::UI::Controls::{DRAWITEMSTRUCT, MEASUREITEMSTRUCT, ODT_MENU, ODS_CHECKED, ODS_DISABLED, ODS_SELECTED},
    Win32::UI::Shell::*,
    Win32::UI::WindowsAndMessaging::*,
};

// Embed the Ekush font directly into the executable
const EKUSH_FONT_DATA: &[u8] = include_bytes!("../fonts/Ekush-Regular.ttf");

// Embed the ICO file
const FLAG_ICO_DATA: &[u8] = include_bytes!("../assets/Flag_of_Bangladesh.ico");

// Global state
static AUTOSTART_ENABLED: AtomicBool = AtomicBool::new(false);
static COUNTRY_SELECTION: AtomicU32 = AtomicU32::new(0); // 0 = Bangladesh, 1 = India

// Custom message for tray icon
const WM_TRAYICON: u32 = WM_USER + 1;

// Menu item IDs
const IDM_AUTOSTART_YES: u32 = 1001;
const IDM_AUTOSTART_NO: u32 = 1002;
const IDM_COUNTRY_BD: u32 = 1003;
const IDM_COUNTRY_IN: u32 = 1004;
const IDM_FONT_LICENSE: u32 = 1005;
const IDM_WEBSITE: u32 = 1006;
const IDM_EXIT: u32 = 1007;

// App constants
const APP_NAME: &str = "BongoWidget";
const POS_KEY_X: &str = "PosX";
const POS_KEY_Y: &str = "PosY";
const COUNTRY_KEY: &str = "Country";

// UI Colors - Modern dark theme
const BG_COLOR: u32 = 0x00201A18;      // Dark brown-black background
const TEXT_PRIMARY: u32 = 0x00FFFFFF;   // White text
const TEXT_SECONDARY: u32 = 0x00B0B0B0; // Light gray
const BORDER_COLOR: u32 = 0x00404040;   // Subtle border

// Widget dimensions
const WIDGET_HEIGHT: i32 = 90;
const CORNER_RADIUS: i32 = 12;
const PADDING: i32 = 8;

// Owner-drawn menu constants
const MENU_ITEM_HEIGHT: i32 = 28;
const MENU_FONT_SIZE: i32 = 18;
const MENU_BG_COLOR: u32 = 0x00FFFFFF;
const MENU_TEXT_COLOR: u32 = 0x00000000;
const MENU_HIGHLIGHT_BG: u32 = 0x00FFE0C0;
const MENU_DISABLED_TEXT: u32 = 0x00808080;
const MENU_CHECK_COLOR: u32 = 0x00008800;

// Bangla ordinal suffixes (১লা, ২রা, etc.)
const BANGLA_ORDINALS: &[&str] = &[
    "",     // 0 (not used)
    "১লা",  // 1
    "২রা",  // 2
    "৩রা",  // 3
    "৪ঠা",  // 4
    "৫ই",   // 5
    "৬ই",   // 6
    "৭ই",   // 7
    "৮ই",   // 8
    "৯ই",   // 9
    "১০ই",  // 10
    "১১ই",  // 11
    "১২ই",  // 12
    "১৩ই",  // 13
    "১৪ই",  // 14
    "১৫ই",  // 15
    "১৬ই",  // 16
    "১৭ই",  // 17
    "১৮ই",  // 18
    "১৯শে", // 19
    "২০শে", // 20
    "২১শে", // 21
    "২২শে", // 22
    "২৩শে", // 23
    "২৪শে", // 24
    "২৫শে", // 25
    "২৬শে", // 26
    "২৭শে", // 27
    "২৮শে", // 28
    "২৯শে", // 29
    "৩০শে", // 30
    "৩১শে", // 31
];

// Bangla month names
const BANGLA_MONTHS: &[&str] = &[
    "বৈশাখ",    // 0 - Boishakh (Apr-May)
    "জ্যৈষ্ঠ",  // 1 - Jyoishtho (May-Jun)
    "আষাঢ়",    // 2 - Asharh (Jun-Jul)
    "শ্রাবণ",   // 3 - Shrabon (Jul-Aug)
    "ভাদ্র",    // 4 - Bhadro (Aug-Sep)
    "আশ্বিন",   // 5 - Ashwin (Sep-Oct)
    "কার্তিক",  // 6 - Kartik (Oct-Nov)
    "অগ্রহায়ণ", // 7 - Ogrohayon (Nov-Dec)
    "পৌষ",      // 8 - Poush (Dec-Jan)
    "মাঘ",      // 9 - Magh (Jan-Feb)
    "ফাল্গুন",  // 10 - Falgun (Feb-Mar)
    "চৈত্র",    // 11 - Choitro (Mar-Apr)
];

// Bangla seasons (ঋতু)
const BANGLA_SEASONS: &[&str] = &[
    "গ্রীষ্ম", // 0 - Grishmo (Summer) - Boishakh
    "গ্রীষ্ম", // 1 - Jyoishtho
    "বর্ষা",   // 2 - Borsha (Rainy) - Asharh
    "বর্ষা",   // 3 - Shrabon
    "শরৎ",     // 4 - Shorot (Autumn) - Bhadro
    "শরৎ",     // 5 - Ashwin
    "হেমন্ত",  // 6 - Hemonto (Late Autumn) - Kartik
    "হেমন্ত",  // 7 - Ogrohayon
    "শীত",     // 8 - Sheet (Winter) - Poush
    "শীত",     // 9 - Magh
    "বসন্ত",   // 10 - Boshonto (Spring) - Falgun
    "বসন্ত",   // 11 - Choitro
];

// Bangla weekday names
const BANGLA_WEEKDAYS: &[&str] = &[
    "রবিবার",    // 0 - Sunday
    "সোমবার",    // 1 - Monday
    "মঙ্গলবার",  // 2 - Tuesday
    "বুধবার",    // 3 - Wednesday
    "বৃহস্পতিবার", // 4 - Thursday
    "শুক্রবার",  // 5 - Friday
    "শনিবার",    // 6 - Saturday
];

// Bangla numerals
const BANGLA_DIGITS: &[char] = &['০', '১', '২', '৩', '৪', '৫', '৬', '৭', '৮', '৯'];

/// Convert English number to Bangla numerals
fn to_bangla_number(num: i32) -> String {
    num.to_string()
        .chars()
        .map(|c| {
            if let Some(digit) = c.to_digit(10) {
                BANGLA_DIGITS[digit as usize]
            } else {
                c
            }
        })
        .collect()
}

/// Bangla date structure
#[derive(Debug, Clone)]
struct BanglaDate {
    day: i32,
    month: i32,
    year: i32,
    weekday: i32,
}

impl BanglaDate {
    fn get_ordinal(&self) -> &'static str {
        if self.day >= 1 && self.day <= 31 {
            BANGLA_ORDINALS[self.day as usize]
        } else {
            "?"
        }
    }

    fn get_month_name(&self) -> &'static str {
        if self.month >= 0 && self.month < 12 {
            BANGLA_MONTHS[self.month as usize]
        } else {
            "?"
        }
    }

    fn get_season(&self) -> &'static str {
        if self.month >= 0 && self.month < 12 {
            BANGLA_SEASONS[self.month as usize]
        } else {
            "?"
        }
    }

    fn get_weekday_name(&self) -> &'static str {
        if self.weekday >= 0 && self.weekday < 7 {
            BANGLA_WEEKDAYS[self.weekday as usize]
        } else {
            "?"
        }
    }

    fn get_year_bangla(&self) -> String {
        to_bangla_number(self.year)
    }

    /// Line 1: ০৬ই পৌষ,
    fn format_line1(&self) -> String {
        format!("{} {},", self.get_ordinal(), self.get_month_name())
    }

    /// Line 2: ১৪৩২ বঙ্গাব্দ
    fn format_line2(&self) -> String {
        format!("{} বঙ্গাব্দ", self.get_year_bangla())
    }

    /// Line 3: শনিবার, হেমন্তকাল
    fn format_line3(&self) -> String {
        format!("{}, {}কাল", self.get_weekday_name(), self.get_season())
    }
}

const BD_MONTH_DAYS: &[i32] = &[31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 30, 30];

fn is_gregorian_leap_year(year: i32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

fn calculate_bangla_date_bd(gregorian_year: i32, gregorian_month: i32, gregorian_day: i32) -> BanglaDate {
    let greg_month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    
    let is_leap = is_gregorian_leap_year(gregorian_year);
    let prev_leap = is_gregorian_leap_year(gregorian_year - 1);
    
    let mut day_of_year = gregorian_day;
    for m in 0..(gregorian_month - 1) {
        day_of_year += greg_month_days[m as usize];
        if m == 1 && is_leap {
            day_of_year += 1;
        }
    }
    
    let boishakh_start = if prev_leap { 105 } else { 104 };
    
    let bangla_year;
    let day_in_bangla_year;
    
    if day_of_year >= boishakh_start {
        bangla_year = gregorian_year - 593;
        day_in_bangla_year = day_of_year - boishakh_start + 1;
    } else {
        bangla_year = gregorian_year - 594;
        let prev_year_days = if prev_leap { 366 } else { 365 };
        day_in_bangla_year = (prev_year_days - boishakh_start + 1) + day_of_year;
    }
    
    let mut remaining_days = day_in_bangla_year;
    let mut bangla_month = 0;
    
    let falgun_days = if is_gregorian_leap_year(bangla_year + 594) { 31 } else { 30 };
    
    for m in 0..12 {
        let month_days = if m == 10 { falgun_days } else { BD_MONTH_DAYS[m] };
        if remaining_days <= month_days {
            bangla_month = m as i32;
            break;
        }
        remaining_days -= month_days;
    }
    
    let bangla_day = remaining_days;
    let weekday = calculate_weekday(gregorian_year, gregorian_month, gregorian_day);
    
    BanglaDate {
        day: bangla_day,
        month: bangla_month,
        year: bangla_year,
        weekday,
    }
}

fn calculate_weekday(year: i32, month: i32, day: i32) -> i32 {
    let mut y = year;
    let mut m = month;
    
    if m < 3 {
        m += 12;
        y -= 1;
    }
    
    let k = y % 100;
    let j = y / 100;
    
    let h = (day + (13 * (m + 1)) / 5 + k + k / 4 + j / 4 - 2 * j) % 7;
    (h + 6) % 7
}

fn get_current_bangla_date() -> BanglaDate {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() as i64;
    
    let bd_timestamp = now + (6 * 3600);
    let adjusted_timestamp = bd_timestamp - (5 * 3600);
    let (year, month, day) = timestamp_to_gregorian(adjusted_timestamp);
    
    calculate_bangla_date_bd(year, month, day)
}

fn timestamp_to_gregorian(timestamp: i64) -> (i32, i32, i32) {
    let mut days = (timestamp / 86400) as i32;
    let mut year = 1970;
    
    loop {
        let days_in_year = if is_gregorian_leap_year(year) { 366 } else { 365 };
        if days < days_in_year {
            break;
        }
        days -= days_in_year;
        year += 1;
    }
    
    let month_days = if is_gregorian_leap_year(year) {
        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    } else {
        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    };
    
    let mut month = 1;
    for (i, &md) in month_days.iter().enumerate() {
        if days < md {
            month = (i + 1) as i32;
            break;
        }
        days -= md;
    }
    
    let day = days + 1;
    (year, month, day)
}

use std::sync::atomic::AtomicPtr;

// Global handles
static mut CUSTOM_FONT: HFONT = HFONT(std::ptr::null_mut());
static mut MENU_FONT: HFONT = HFONT(std::ptr::null_mut());
static FLAG_ICON_PTR: AtomicPtr<std::ffi::c_void> = AtomicPtr::new(std::ptr::null_mut());

// Storage for owner-drawn menu item strings
static MENU_STRINGS: std::sync::Mutex<Vec<String>> = std::sync::Mutex::new(Vec::new());

fn get_flag_icon() -> HICON {
    HICON(FLAG_ICON_PTR.load(Ordering::SeqCst))
}

fn set_flag_icon(icon: HICON) {
    FLAG_ICON_PTR.store(icon.0, Ordering::SeqCst);
}

fn main() -> Result<()> {
    unsafe {
        // Enable autostart by default on first run
        let autostart_status = is_autostart_enabled();
        if !autostart_status && !has_run_before() {
            toggle_autostart(true);
            mark_has_run();
        }
        AUTOSTART_ENABLED.store(is_autostart_enabled(), Ordering::SeqCst);
        COUNTRY_SELECTION.store(load_country_selection(), Ordering::SeqCst);

        install_embedded_font();
        create_flag_icon();

        let instance = GetModuleHandleW(None)?;
        let window_class = w!("BongoWidgetClass");

        // Use our custom flag icon for the window class
        let flag_icon = get_flag_icon();
        let wc = WNDCLASSEXW {
            cbSize: std::mem::size_of::<WNDCLASSEXW>() as u32,
            style: CS_HREDRAW | CS_VREDRAW,
            lpfnWndProc: Some(wndproc),
            hInstance: instance.into(),
            hCursor: LoadCursorW(None, IDC_ARROW)?,
            hbrBackground: HBRUSH(std::ptr::null_mut()),
            lpszClassName: window_class,
            hIcon: flag_icon,
            hIconSm: flag_icon,
            ..Default::default()
        };

        RegisterClassExW(&wc);

        let screen_width = GetSystemMetrics(SM_CXSCREEN);
        let screen_height = GetSystemMetrics(SM_CYSCREEN);

        // Calculate widget width based on text
        let widget_width = calculate_widget_width();

        let (saved_x, saved_y) = load_position();
        let x = if saved_x >= 0 && saved_x < screen_width - 50 {
            saved_x
        } else {
            screen_width - widget_width - 20
        };
        let y = if saved_y >= 0 && saved_y < screen_height - 50 {
            saved_y
        } else {
            screen_height - WIDGET_HEIGHT - 80
        };

        let hwnd = CreateWindowExW(
            WS_EX_TOOLWINDOW | WS_EX_LAYERED,
            window_class,
            w!("বাংলা ক্যালেন্ডার"),
            WS_POPUP | WS_VISIBLE,
            x,
            y,
            widget_width,
            WIDGET_HEIGHT,
            None,
            None,
            Some(instance.into()),
            None,
        )?;

        // Explicitly set window icon for Task Manager
        if !flag_icon.is_invalid() {
            SendMessageW(hwnd, WM_SETICON, Some(WPARAM(ICON_BIG as usize)), Some(LPARAM(flag_icon.0 as isize)));
            SendMessageW(hwnd, WM_SETICON, Some(WPARAM(ICON_SMALL as usize)), Some(LPARAM(flag_icon.0 as isize)));
        }

        // Use color key for transparency (black = transparent)
        SetLayeredWindowAttributes(hwnd, COLORREF(0x00000000), 0, LWA_COLORKEY)?;

        set_desktop_level(hwnd);
        create_tray_icon(hwnd)?;
        SetTimer(Some(hwnd), 1, 60000, None);

        let mut message = MSG::default();
        while GetMessageW(&mut message, None, 0, 0).into() {
            let _ = TranslateMessage(&message);
            DispatchMessageW(&message);
        }

        KillTimer(Some(hwnd), 1)?;
        remove_tray_icon(hwnd)?;

        Ok(())
    }
}

/// Calculate the optimal widget width based on text content
fn calculate_widget_width() -> i32 {
    let bangla_date = get_current_bangla_date();
    let line1 = bangla_date.format_line1();
    let line2 = bangla_date.format_line2();
    let line3 = bangla_date.format_line3();
    
    // Estimate width based on character count (Bangla characters are wider)
    let max_chars = line1.chars().count().max(line2.chars().count()).max(line3.chars().count());
    let text_width = (max_chars as i32 * 11).max(120); // Even tighter width
    
    text_width + (PADDING * 2) // just text + padding on both sides
}

unsafe fn install_embedded_font() {
    let mut num_fonts: u32 = 0;
    let _font_handle = unsafe {
        AddFontMemResourceEx(
            EKUSH_FONT_DATA.as_ptr() as *const std::ffi::c_void,
            EKUSH_FONT_DATA.len() as u32,
            None,
            &mut num_fonts,
        )
    };

    if num_fonts > 0 {
        unsafe {
            CUSTOM_FONT = CreateFontW(
                24,
                0, 0, 0,
                FW_NORMAL.0 as i32,
                0, 0, 0,
                DEFAULT_CHARSET,
                OUT_DEFAULT_PRECIS,
                CLIP_DEFAULT_PRECIS,
                CLEARTYPE_QUALITY,
                (DEFAULT_PITCH.0 | FF_DONTCARE.0) as u32,
                w!("Ekush"),
            );
            
            // Create menu font for owner-drawn menus
            MENU_FONT = CreateFontW(
                MENU_FONT_SIZE,
                0, 0, 0,
                FW_NORMAL.0 as i32,
                0, 0, 0,
                DEFAULT_CHARSET,
                OUT_DEFAULT_PRECIS,
                CLIP_DEFAULT_PRECIS,
                CLEARTYPE_QUALITY,
                (DEFAULT_PITCH.0 | FF_DONTCARE.0) as u32,
                w!("Ekush"),
            );
        }
    }
}

/// Load Bangladesh flag icon from embedded ICO file
unsafe fn create_flag_icon() {
    unsafe {
        // Create icon from memory using CreateIconFromResourceEx
        let icon = CreateIconFromResourceEx(
            FLAG_ICO_DATA,
            true,
            0x00030000, // Icon version
            32,
            32,
            LR_DEFAULTCOLOR,
        );
        
        if let Ok(ico) = icon {
            set_flag_icon(ico);
        }
    }
}

unsafe fn create_tray_icon(hwnd: HWND) -> Result<()> {
    let flag_icon = get_flag_icon();
    let mut nid = NOTIFYICONDATAW {
        cbSize: std::mem::size_of::<NOTIFYICONDATAW>() as u32,
        hWnd: hwnd,
        uID: 1,
        uFlags: NIF_ICON | NIF_MESSAGE | NIF_TIP,
        uCallbackMessage: WM_TRAYICON,
        hIcon: unsafe { if !flag_icon.is_invalid() { flag_icon } else { LoadIconW(None, IDI_APPLICATION)? } },
        ..Default::default()
    };

    let tip = "বাংলা ক্যালেন্ডার -  বাংলা তারিখ";
    let tip_wide: Vec<u16> = tip.encode_utf16().chain(std::iter::once(0)).collect();
    let len = tip_wide.len().min(128);
    nid.szTip[..len].copy_from_slice(&tip_wide[..len]);

    let result = unsafe { Shell_NotifyIconW(NIM_ADD, &nid) };
    if !result.as_bool() {
        return Err(Error::from_win32());
    }
    Ok(())
}

unsafe fn remove_tray_icon(hwnd: HWND) -> Result<()> {
    let nid = NOTIFYICONDATAW {
        cbSize: std::mem::size_of::<NOTIFYICONDATAW>() as u32,
        hWnd: hwnd,
        uID: 1,
        ..Default::default()
    };
    let result = unsafe { Shell_NotifyIconW(NIM_DELETE, &nid) };
    if !result.as_bool() {
        return Err(Error::from_win32());
    }
    Ok(())
}

/// Helper to add an owner-drawn menu item
unsafe fn add_owner_drawn_item(menu: HMENU, position: u32, id: u32, text: &str, is_checked: bool, is_disabled: bool, is_separator: bool) {
    // Store the string and get its index
    let index = {
        let mut strings = MENU_STRINGS.lock().unwrap();
        let idx = strings.len();
        strings.push(text.to_string());
        idx
    };
    
    if is_separator {
        let mii = MENUITEMINFOW {
            cbSize: std::mem::size_of::<MENUITEMINFOW>() as u32,
            fMask: MIIM_FTYPE,
            fType: MFT_SEPARATOR,
            ..Default::default()
        };
        unsafe { let _ = InsertMenuItemW(menu, position, true, &mii); }
    } else {
        let mut state = MENU_ITEM_STATE(0);
        if is_checked { state |= MFS_CHECKED; }
        if is_disabled { state |= MFS_DISABLED; }
        
        let mii = MENUITEMINFOW {
            cbSize: std::mem::size_of::<MENUITEMINFOW>() as u32,
            fMask: MIIM_FTYPE | MIIM_ID | MIIM_STATE | MIIM_DATA,
            fType: MFT_OWNERDRAW,
            fState: state,
            wID: id,
            dwItemData: index,
            ..Default::default()
        };
        unsafe { let _ = InsertMenuItemW(menu, position, true, &mii); }
    }
}

/// Helper to add an owner-drawn submenu
unsafe fn add_owner_drawn_submenu(menu: HMENU, position: u32, submenu: HMENU, text: &str) {
    let index = {
        let mut strings = MENU_STRINGS.lock().unwrap();
        let idx = strings.len();
        strings.push(text.to_string());
        idx
    };
    
    let mii = MENUITEMINFOW {
        cbSize: std::mem::size_of::<MENUITEMINFOW>() as u32,
        fMask: MIIM_FTYPE | MIIM_SUBMENU | MIIM_DATA,
        fType: MFT_OWNERDRAW,
        hSubMenu: submenu,
        dwItemData: index,
        ..Default::default()
    };
    unsafe { let _ = InsertMenuItemW(menu, position, true, &mii); }
}

unsafe fn show_context_menu(hwnd: HWND) {
    unsafe {
        // Clear previous menu strings
        {
            let mut strings = MENU_STRINGS.lock().unwrap();
            strings.clear();
        }
        
        let menu = CreatePopupMenu().unwrap();
        let autostart = AUTOSTART_ENABLED.load(Ordering::SeqCst);
        let country = COUNTRY_SELECTION.load(Ordering::SeqCst);

        // বুট হওয়ার সময়ে খোলো - Submenu
        let autostart_submenu = CreatePopupMenu().unwrap();
        add_owner_drawn_item(autostart_submenu, 0, IDM_AUTOSTART_YES, "হ্যাঁ", autostart, false, false);
        add_owner_drawn_item(autostart_submenu, 1, IDM_AUTOSTART_NO, "না", !autostart, false, false);
        add_owner_drawn_submenu(menu, 0, autostart_submenu, "বুট হওয়ার সময়ে খোলো");

        // দেশ - Submenu
        let country_submenu = CreatePopupMenu().unwrap();
        add_owner_drawn_item(country_submenu, 0, IDM_COUNTRY_BD, "বাংলাদেশ", country == 0, false, false);
        add_owner_drawn_item(country_submenu, 1, IDM_COUNTRY_IN, "ভারত (শীঘ্রই আসছে)", false, true, false);
        add_owner_drawn_submenu(menu, 1, country_submenu, "দেশ");

        // Separator
        add_owner_drawn_item(menu, 2, 0, "", false, false, true);

        // ফন্ট লাইসেন্স
        add_owner_drawn_item(menu, 3, IDM_FONT_LICENSE, "ফন্ট লাইসেন্স", false, false, false);

        // ওয়েবসাইট
        add_owner_drawn_item(menu, 4, IDM_WEBSITE, "ওয়েবসাইট", false, false, false);

        // Separator
        add_owner_drawn_item(menu, 5, 0, "", false, false, true);

        // বন্ধ করুন
        add_owner_drawn_item(menu, 6, IDM_EXIT, "বন্ধ করুন", false, false, false);

        let mut pt = POINT::default();
        let _ = GetCursorPos(&mut pt);
        let _ = SetForegroundWindow(hwnd);
        let _ = TrackPopupMenu(menu, TPM_RIGHTBUTTON, pt.x, pt.y, Some(0), hwnd, None);
        let _ = DestroyMenu(menu);
    }
}

unsafe fn open_url(url: &str) {
    let url_wide: Vec<u16> = url.encode_utf16().chain(std::iter::once(0)).collect();
    let operation = w!("open");
    
    unsafe {
        ShellExecuteW(
            None,
            operation,
            PCWSTR(url_wide.as_ptr()),
            None,
            None,
            SW_SHOWNORMAL,
        );
    }
}

unsafe fn is_autostart_enabled() -> bool {
    let key_path = w!("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
    let mut hkey = HKEY::default();

    if unsafe { RegOpenKeyExW(HKEY_CURRENT_USER, key_path, Some(0), KEY_READ, &mut hkey) }.is_ok() {
        let value_name = HSTRING::from(APP_NAME);
        let result = unsafe { RegQueryValueExW(hkey, &value_name, None, None, None, None) };
        unsafe { let _ = RegCloseKey(hkey); }
        result.is_ok()
    } else {
        false
    }
}

unsafe fn load_country_selection() -> u32 {
    let key_path = w!("Software\\BongoWidget");
    let mut hkey = HKEY::default();
    let mut country: u32 = 0;

    if unsafe { RegOpenKeyExW(HKEY_CURRENT_USER, key_path, Some(0), KEY_READ, &mut hkey) }.is_ok() {
        let mut data: u32 = 0;
        let mut size = std::mem::size_of::<u32>() as u32;
        let value_name = HSTRING::from(COUNTRY_KEY);

        if unsafe {
            RegQueryValueExW(
                hkey,
                &value_name,
                None,
                None,
                Some(&mut data as *mut u32 as *mut u8),
                Some(&mut size),
            )
        }
        .is_ok()
        {
            country = data;
        }
        unsafe { let _ = RegCloseKey(hkey); }
    }
    country
}

unsafe fn save_country_selection(country: u32) {
    let key_path = w!("Software\\BongoWidget");
    let mut hkey = HKEY::default();

    if unsafe { RegCreateKeyW(HKEY_CURRENT_USER, key_path, &mut hkey) }.is_ok() {
        let value_name = HSTRING::from(COUNTRY_KEY);
        unsafe {
            let _ = RegSetValueExW(
                hkey,
                &value_name,
                Some(0),
                REG_DWORD,
                Some(std::slice::from_raw_parts(
                    &country as *const u32 as *const u8,
                    std::mem::size_of::<u32>(),
                )),
            );
            let _ = RegCloseKey(hkey);
        }
    }
}

unsafe fn set_desktop_level(hwnd: HWND) {
    let progman = unsafe { FindWindowW(w!("Progman"), None) };

    if let Ok(progman) = progman {
        if !progman.is_invalid() {
            unsafe {
                let _ = SendMessageTimeoutW(
                    progman,
                    0x052C,
                    WPARAM(0),
                    LPARAM(0),
                    SMTO_NORMAL,
                    1000,
                    None,
                );
            }

            let mut worker_w = HWND::default();
            let mut found_worker = HWND::default();

            loop {
                worker_w = unsafe { FindWindowExW(None, Some(worker_w), w!("WorkerW"), None) }
                    .unwrap_or_default();
                if worker_w.is_invalid() {
                    break;
                }

                let shell_view = unsafe {
                    FindWindowExW(Some(worker_w), None, w!("SHELLDLL_DefView"), None)
                }
                .unwrap_or_default();
                if !shell_view.is_invalid() {
                    found_worker =
                        unsafe { FindWindowExW(None, Some(worker_w), w!("WorkerW"), None) }
                            .unwrap_or_default();
                    break;
                }
            }

            if !found_worker.is_invalid() {
                unsafe { let _ = SetParent(hwnd, Some(found_worker)); }
                return;
            }
        }
    }

    unsafe {
        let _ = SetWindowPos(
            hwnd,
            Some(HWND_BOTTOM),
            0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE,
        );
    }
}

unsafe fn load_position() -> (i32, i32) {
    let key_path = w!("Software\\BongoWidget");
    let mut hkey = HKEY::default();
    let mut x: i32 = -1;
    let mut y: i32 = -1;

    if unsafe { RegOpenKeyExW(HKEY_CURRENT_USER, key_path, Some(0), KEY_READ, &mut hkey) }.is_ok() {
        let mut data_x: u32 = 0;
        let mut data_y: u32 = 0;
        let mut size = std::mem::size_of::<u32>() as u32;

        let value_x = HSTRING::from(POS_KEY_X);
        let value_y = HSTRING::from(POS_KEY_Y);

        if unsafe {
            RegQueryValueExW(
                hkey,
                &value_x,
                None,
                None,
                Some(&mut data_x as *mut u32 as *mut u8),
                Some(&mut size),
            )
        }
        .is_ok()
        {
            x = data_x as i32;
        }

        size = std::mem::size_of::<u32>() as u32;
        if unsafe {
            RegQueryValueExW(
                hkey,
                &value_y,
                None,
                None,
                Some(&mut data_y as *mut u32 as *mut u8),
                Some(&mut size),
            )
        }
        .is_ok()
        {
            y = data_y as i32;
        }

        unsafe { let _ = RegCloseKey(hkey); }
    }

    (x, y)
}

unsafe fn save_position(x: i32, y: i32) {
    let key_path = w!("Software\\BongoWidget");
    let mut hkey = HKEY::default();

    if unsafe { RegCreateKeyW(HKEY_CURRENT_USER, key_path, &mut hkey) }.is_ok() {
        let value_x = HSTRING::from(POS_KEY_X);
        let value_y = HSTRING::from(POS_KEY_Y);
        let x_u32 = x as u32;
        let y_u32 = y as u32;

        unsafe {
            let _ = RegSetValueExW(
                hkey,
                &value_x,
                Some(0),
                REG_DWORD,
                Some(std::slice::from_raw_parts(
                    &x_u32 as *const u32 as *const u8,
                    std::mem::size_of::<u32>(),
                )),
            );

            let _ = RegSetValueExW(
                hkey,
                &value_y,
                Some(0),
                REG_DWORD,
                Some(std::slice::from_raw_parts(
                    &y_u32 as *const u32 as *const u8,
                    std::mem::size_of::<u32>(),
                )),
            );

            let _ = RegCloseKey(hkey);
        }
    }
}

unsafe fn toggle_autostart(enable: bool) {
    let key_path = w!("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
    let mut hkey = HKEY::default();

    if unsafe { RegOpenKeyExW(HKEY_CURRENT_USER, key_path, Some(0), KEY_WRITE, &mut hkey) }.is_ok()
    {
        let value_name = HSTRING::from(APP_NAME);

        if enable {
            if let Ok(exe_path) = std::env::current_exe() {
                let path_str = exe_path.to_string_lossy();
                let path_wide: Vec<u16> =
                    path_str.encode_utf16().chain(std::iter::once(0)).collect();
                let path_bytes = unsafe {
                    std::slice::from_raw_parts(path_wide.as_ptr() as *const u8, path_wide.len() * 2)
                };
                unsafe {
                    let _ = RegSetValueExW(hkey, &value_name, Some(0), REG_SZ, Some(path_bytes));
                }
                AUTOSTART_ENABLED.store(true, Ordering::SeqCst);
            }
        } else {
            unsafe { let _ = RegDeleteValueW(hkey, &value_name); }
            AUTOSTART_ENABLED.store(false, Ordering::SeqCst);
        }
        unsafe { let _ = RegCloseKey(hkey); }
    }
}

/// Check if the app has run before
unsafe fn has_run_before() -> bool {
    let key_path = w!("Software\\BongoWidget");
    let mut hkey = HKEY::default();

    if unsafe { RegOpenKeyExW(HKEY_CURRENT_USER, key_path, Some(0), KEY_READ, &mut hkey) }.is_ok() {
        let mut data: u32 = 0;
        let mut size = std::mem::size_of::<u32>() as u32;
        let value_name = HSTRING::from("HasRun");

        let result = unsafe {
            RegQueryValueExW(
                hkey,
                &value_name,
                None,
                None,
                Some(&mut data as *mut u32 as *mut u8),
                Some(&mut size),
            )
        };
        unsafe { let _ = RegCloseKey(hkey); }
        result.is_ok() && data == 1
    } else {
        false
    }
}

/// Mark that the app has run before
unsafe fn mark_has_run() {
    let key_path = w!("Software\\BongoWidget");
    let mut hkey = HKEY::default();

    if unsafe { RegCreateKeyW(HKEY_CURRENT_USER, key_path, &mut hkey) }.is_ok() {
        let value_name = HSTRING::from("HasRun");
        let data: u32 = 1;
        unsafe {
            let _ = RegSetValueExW(
                hkey,
                &value_name,
                Some(0),
                REG_DWORD,
                Some(std::slice::from_raw_parts(
                    &data as *const u32 as *const u8,
                    std::mem::size_of::<u32>(),
                )),
            );
            let _ = RegCloseKey(hkey);
        }
    }
}

/// Draw rounded rectangle with GDI
unsafe fn draw_rounded_rect(hdc: HDC, rect: &RECT, radius: i32, brush: HBRUSH) {
    unsafe {
        let rgn = CreateRoundRectRgn(
            rect.left,
            rect.top,
            rect.right,
            rect.bottom,
            radius * 2,
            radius * 2,
        );
        let _ = FillRgn(hdc, rgn, brush);
        let _ = DeleteObject(rgn.into());
    }
}

extern "system" fn wndproc(hwnd: HWND, message: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
    unsafe {
        match message {
            WM_CREATE => LRESULT(0),
            
            WM_MEASUREITEM => {
                let mis = lparam.0 as *mut MEASUREITEMSTRUCT;
                if !mis.is_null() {
                    (*mis).itemHeight = MENU_ITEM_HEIGHT as u32;
                    (*mis).itemWidth = 200; // Default width, will be adjusted
                    
                    // Calculate text width using menu font
                    let index = (*mis).itemData;
                    if let Ok(strings) = MENU_STRINGS.lock() {
                        if let Some(text) = strings.get(index) {
                            let hdc = GetDC(Some(hwnd));
                            let old_font = SelectObject(hdc, MENU_FONT.into());
                            let text_wide: Vec<u16> = text.encode_utf16().collect();
                            let mut size = SIZE::default();
                            let _ = GetTextExtentPoint32W(hdc, &text_wide, &mut size);
                            SelectObject(hdc, old_font);
                            let _ = ReleaseDC(Some(hwnd), hdc);
                            (*mis).itemWidth = (size.cx + 40) as u32; // Add padding for checkmark and arrow
                        }
                    }
                }
                LRESULT(1)
            }
            
            WM_DRAWITEM => {
                let dis = lparam.0 as *const DRAWITEMSTRUCT;
                if !dis.is_null() && (*dis).CtlType == ODT_MENU {
                    let hdc = (*dis).hDC;
                    let rc = (*dis).rcItem;
                    let is_selected = ((*dis).itemState.0 & ODS_SELECTED.0) != 0;
                    let is_disabled = ((*dis).itemState.0 & ODS_DISABLED.0) != 0;
                    let is_checked = ((*dis).itemState.0 & ODS_CHECKED.0) != 0;
                    
                    // Draw background
                    let bg_color = if is_selected { MENU_HIGHLIGHT_BG } else { MENU_BG_COLOR };
                    let bg_brush = CreateSolidBrush(COLORREF(bg_color));
                    FillRect(hdc, &rc, bg_brush);
                    let _ = DeleteObject(bg_brush.into());
                    
                    // Draw text
                    let index = (*dis).itemData;
                    if let Ok(strings) = MENU_STRINGS.lock() {
                        if let Some(text) = strings.get(index) {
                            let old_font = SelectObject(hdc, MENU_FONT.into());
                            SetBkMode(hdc, TRANSPARENT);
                            
                            let text_color = if is_disabled { MENU_DISABLED_TEXT } else { MENU_TEXT_COLOR };
                            SetTextColor(hdc, COLORREF(text_color));
                            
                            let mut text_rect = rc;
                            text_rect.left += 28; // Leave space for checkmark
                            text_rect.right -= 10;
                            
                            let mut text_wide: Vec<u16> = text.encode_utf16().collect();
                            DrawTextW(hdc, &mut text_wide, &mut text_rect, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
                            
                            SelectObject(hdc, old_font);
                            
                            // Draw checkmark if checked
                            if is_checked {
                                let check_font = CreateFontW(
                                    16, 0, 0, 0,
                                    FW_BOLD.0 as i32,
                                    0, 0, 0,
                                    DEFAULT_CHARSET,
                                    OUT_DEFAULT_PRECIS,
                                    CLIP_DEFAULT_PRECIS,
                                    CLEARTYPE_QUALITY,
                                    (DEFAULT_PITCH.0 | FF_DONTCARE.0) as u32,
                                    w!("Segoe UI Symbol"),
                                );
                                let old_check_font = SelectObject(hdc, check_font.into());
                                SetTextColor(hdc, COLORREF(MENU_CHECK_COLOR));
                                let mut check_rect = rc;
                                check_rect.left += 6;
                                check_rect.right = check_rect.left + 20;
                                let mut check_mark: Vec<u16> = "✓".encode_utf16().collect();
                                DrawTextW(hdc, &mut check_mark, &mut check_rect, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
                                SelectObject(hdc, old_check_font);
                                let _ = DeleteObject(check_font.into());
                            }
                        }
                    }
                }
                LRESULT(1)
            }
            
            WM_TIMER => {
                let _ = InvalidateRect(Some(hwnd), None, true);
                LRESULT(0)
            }
            
            WM_PAINT => {
                let mut ps = PAINTSTRUCT::default();
                let hdc = BeginPaint(hwnd, &mut ps);

                let mut rect = RECT::default();
                let _ = GetClientRect(hwnd, &mut rect);

                // Create memory DC for double buffering
                let mem_dc = CreateCompatibleDC(Some(hdc));
                let mem_bitmap = CreateCompatibleBitmap(hdc, rect.right, rect.bottom);
                let old_bitmap = SelectObject(mem_dc, mem_bitmap.into());

                // Fill with transparent color (black will be transparent)
                let trans_brush = CreateSolidBrush(COLORREF(0x00000000));
                FillRect(mem_dc, &rect, trans_brush);
                let _ = DeleteObject(trans_brush.into());

                // Draw main rounded background (dark)
                let bg_brush = CreateSolidBrush(COLORREF(BG_COLOR));
                draw_rounded_rect(mem_dc, &rect, CORNER_RADIUS, bg_brush);
                let _ = DeleteObject(bg_brush.into());

                // Draw subtle border
                let border_pen = CreatePen(PS_SOLID, 1, COLORREF(BORDER_COLOR));
                let old_pen = SelectObject(mem_dc, border_pen.into());
                let null_brush = GetStockObject(NULL_BRUSH);
                let old_brush = SelectObject(mem_dc, null_brush);
                let _ = RoundRect(mem_dc, rect.left, rect.top, rect.right, rect.bottom, CORNER_RADIUS * 2, CORNER_RADIUS * 2);
                SelectObject(mem_dc, old_pen);
                SelectObject(mem_dc, old_brush);
                let _ = DeleteObject(border_pen.into());

                // Set text properties
                SetBkMode(mem_dc, TRANSPARENT);

                // Get current Bangla date
                let bangla_date = get_current_bangla_date();

                // Text area with padding
                let text_left = rect.left + PADDING;
                let text_right = rect.right - PADDING;

                // Create fonts
                let font_line1 = CreateFontW(
                    26, // Slightly bigger for line 1
                    0, 0, 0,
                    FW_SEMIBOLD.0 as i32,
                    0, 0, 0,
                    DEFAULT_CHARSET,
                    OUT_DEFAULT_PRECIS,
                    CLIP_DEFAULT_PRECIS,
                    CLEARTYPE_QUALITY,
                    (DEFAULT_PITCH.0 | FF_DONTCARE.0) as u32,
                    w!("Ekush"),
                );

                let font_line2 = CreateFontW(
                    22,
                    0, 0, 0,
                    FW_NORMAL.0 as i32,
                    0, 0, 0,
                    DEFAULT_CHARSET,
                    OUT_DEFAULT_PRECIS,
                    CLIP_DEFAULT_PRECIS,
                    CLEARTYPE_QUALITY,
                    (DEFAULT_PITCH.0 | FF_DONTCARE.0) as u32,
                    w!("Ekush"),
                );

                let font_line3 = CreateFontW(
                    18,
                    0, 0, 0,
                    FW_NORMAL.0 as i32,
                    0, 0, 0,
                    DEFAULT_CHARSET,
                    OUT_DEFAULT_PRECIS,
                    CLIP_DEFAULT_PRECIS,
                    CLEARTYPE_QUALITY,
                    (DEFAULT_PITCH.0 | FF_DONTCARE.0) as u32,
                    w!("Ekush"),
                );

                // Line 1: ০৬ই পৌষ, (bigger, white)
                let old_font = SelectObject(mem_dc, font_line1.into());
                SetTextColor(mem_dc, COLORREF(TEXT_PRIMARY));
                let line1_text = bangla_date.format_line1();
                let mut line1_vec: Vec<u16> = line1_text.encode_utf16().collect();
                let mut line1_rect = RECT {
                    left: text_left,
                    top: 12,
                    right: text_right,
                    bottom: 38,
                };
                DrawTextW(mem_dc, &mut line1_vec, &mut line1_rect, DT_CENTER | DT_SINGLELINE);

                // Line 2: ১৪৩২ বঙ্গাব্দ (normal, white)
                SelectObject(mem_dc, font_line2.into());
                let line2_text = bangla_date.format_line2();
                let mut line2_vec: Vec<u16> = line2_text.encode_utf16().collect();
                let mut line2_rect = RECT {
                    left: text_left,
                    top: 38,
                    right: text_right,
                    bottom: 60,
                };
                DrawTextW(mem_dc, &mut line2_vec, &mut line2_rect, DT_CENTER | DT_SINGLELINE);

                // Line 3: শনিবার, হেমন্তকাল (smaller, gray)
                SelectObject(mem_dc, font_line3.into());
                SetTextColor(mem_dc, COLORREF(TEXT_SECONDARY));
                let line3_text = bangla_date.format_line3();
                let mut line3_vec: Vec<u16> = line3_text.encode_utf16().collect();
                let mut line3_rect = RECT {
                    left: text_left,
                    top: 62,
                    right: text_right,
                    bottom: 82,
                };
                DrawTextW(mem_dc, &mut line3_vec, &mut line3_rect, DT_CENTER | DT_SINGLELINE);

                SelectObject(mem_dc, old_font);
                let _ = DeleteObject(font_line1.into());
                let _ = DeleteObject(font_line2.into());
                let _ = DeleteObject(font_line3.into());

                // Copy to screen
                let _ = BitBlt(hdc, 0, 0, rect.right, rect.bottom, Some(mem_dc), 0, 0, SRCCOPY);

                // Cleanup
                SelectObject(mem_dc, old_bitmap);
                let _ = DeleteObject(mem_bitmap.into());
                let _ = DeleteDC(mem_dc);

                let _ = EndPaint(hwnd, &ps);
                LRESULT(0)
            }
            
            WM_LBUTTONDOWN => {
                let _ = DefWindowProcW(hwnd, WM_SYSCOMMAND, WPARAM(0xF012), LPARAM(0));
                LRESULT(0)
            }
            
            WM_MOVE => {
                let mut rect = RECT::default();
                if GetWindowRect(hwnd, &mut rect).is_ok() {
                    save_position(rect.left, rect.top);
                }
                LRESULT(0)
            }
            
            WM_RBUTTONUP => {
                show_context_menu(hwnd);
                LRESULT(0)
            }
            
            WM_TRAYICON => {
                let event = (lparam.0 & 0xFFFF) as u32;
                if event == WM_RBUTTONUP {
                    show_context_menu(hwnd);
                }
                LRESULT(0)
            }
            
            // Set rounded corners on popup menus (Windows 11)
            WM_ENTERIDLE => {
                if wparam.0 == 2 { // MSGF_MENU
                    let menu_hwnd = HWND(lparam.0 as *mut std::ffi::c_void);
                    if !menu_hwnd.is_invalid() {
                        let preference = DWM_WINDOW_CORNER_PREFERENCE(2); // DWMWCP_ROUND
                        let _ = DwmSetWindowAttribute(
                            menu_hwnd,
                            DWMWA_WINDOW_CORNER_PREFERENCE,
                            &preference as *const _ as *const std::ffi::c_void,
                            std::mem::size_of::<DWM_WINDOW_CORNER_PREFERENCE>() as u32,
                        );
                    }
                }
                LRESULT(0)
            }
            
            WM_COMMAND => {
                let cmd = (wparam.0 & 0xFFFF) as u32;
                match cmd {
                    IDM_AUTOSTART_YES => {
                        toggle_autostart(true);
                    }
                    IDM_AUTOSTART_NO => {
                        toggle_autostart(false);
                    }
                    IDM_COUNTRY_BD => {
                        COUNTRY_SELECTION.store(0, Ordering::SeqCst);
                        save_country_selection(0);
                        let _ = InvalidateRect(Some(hwnd), None, true);
                    }
                    IDM_COUNTRY_IN => {
                        // India - disabled for now
                    }
                    IDM_FONT_LICENSE => {
                        open_url("https://codepotro.com/font/ekush/");
                    }
                    IDM_WEBSITE => {
                        open_url("https://sayed.app");
                    }
                    IDM_EXIT => {
                        let _ = DestroyWindow(hwnd);
                    }
                    _ => {}
                }
                LRESULT(0)
            }
            
            WM_DESTROY => {
                PostQuitMessage(0);
                LRESULT(0)
            }
            
            _ => DefWindowProcW(hwnd, message, wparam, lparam),
        }
    }
}
